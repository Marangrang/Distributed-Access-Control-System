name: CD - Build and Deploy Locally

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: self-hosted
    timeout-minutes: 30
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Load environment variables
        shell: powershell
        run: |
          if (Test-Path .env) {
            Get-Content .env | ForEach-Object {
              if ($_ -match '^([^#].+?)=(.+)$') {
                $name = $matches[1].Trim()
                $value = $matches[2].Trim()
                Write-Host "Setting $name"
                [Environment]::SetEnvironmentVariable($name, $value, "Process")
              }
            }
          }

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Stop and remove existing containers
        shell: powershell
        run: |
          Write-Host "Stopping existing containers..."
          docker compose down --remove-orphans --volumes
          Start-Sleep -Seconds 5

      - name: Clean up Docker cache (optional)
        if: github.event_name == 'workflow_dispatch'
        shell: powershell
        run: |
          Write-Host "Cleaning up Docker cache..."
          docker system prune -af --volumes
          Write-Host "[OK] Docker cache cleaned"

      - name: Build Docker images with cache
        shell: powershell
        env:
          DOCKER_BUILDKIT: 1
          COMPOSE_DOCKER_CLI_BUILD: 1
        run: |
          Write-Host "Building Docker images with BuildKit cache..."
          
          docker compose build `
            --build-arg BUILDKIT_INLINE_CACHE=1 `
            --progress=plain
          
          Write-Host "[OK] Docker images built successfully"

      - name: Start services
        shell: powershell
        run: |
          Write-Host "Starting services..."
          docker compose up -d
          Write-Host "[OK] Services started"

      - name: Wait for services to be healthy
        shell: powershell
        timeout-minutes: 5
        run: |
          Write-Host "Waiting for services to be healthy..."
          
          $maxAttempts = 30
          $attempt = 0
          $allHealthy = $false
          
          while (-not $allHealthy -and $attempt -lt $maxAttempts) {
            $attempt++
            Write-Host "Health check attempt $attempt/$maxAttempts..."
            
            $services = docker compose ps --format json | ConvertFrom-Json
            $unhealthy = $services | Where-Object { 
              $_.Health -ne "healthy" -and $_.State -eq "running" 
            }
            
            if ($unhealthy.Count -eq 0) {
              $allHealthy = $true
              Write-Host "[OK] All services are healthy"
            } else {
              Write-Host "Waiting for: $($unhealthy.Service -join ', ')"
              Start-Sleep -Seconds 5
            }
          }
          
          if (-not $allHealthy) {
            Write-Host "[ERROR] Services failed to become healthy"
            docker compose ps
            docker compose logs --tail=50
            exit 1
          }

      - name: Smoke Test - API Health
        shell: powershell
        timeout-minutes: 2
        run: |
          Write-Host "Running smoke tests..."
          $deadline = (Get-Date).AddMinutes(2)
          $ok = $false
          
          Write-Host "Testing API health endpoint..."
          while (-not $ok -and (Get-Date) -lt $deadline) {
            try {
              $res = Invoke-RestMethod -Uri "http://localhost:8080/health" -TimeoutSec 5
              if ($res.status -eq 'ok' -or $res -eq 'ok') {
                Write-Host "[OK] Health check passed: $res"
                $ok = $true
              }
            } catch {
              Write-Host "Health check failed, retrying..."
              Start-Sleep -Seconds 5
            }
          }
          
          if (-not $ok) {
            Write-Host "[ERROR] Health check failed after timeout"
            docker compose logs app --tail=50
            exit 1
          }

      - name: Smoke Test - Verify Endpoints
        shell: powershell
        run: |
          Write-Host "Testing critical endpoints..."
          
          try {
            $metrics = Invoke-WebRequest -Uri "http://localhost:8080/metrics" -TimeoutSec 5
            if ($metrics.StatusCode -eq 200) {
              Write-Host "[OK] Metrics endpoint: OK"
            } else {
              throw "Metrics endpoint returned: $($metrics.StatusCode)"
            }
          } catch {
            Write-Host "[ERROR] Metrics endpoint failed: $_"
            exit 1
          }
          
          Write-Host "[OK] All smoke tests passed"

      - name: Smoke Test - Database Connectivity
        shell: powershell
        run: |
          Write-Host "Testing database connectivity..."
          $dbCheck = docker compose exec -T db pg_isready -U $env:DB_USER -d $env:DB_NAME
          if ($LASTEXITCODE -eq 0) {
            Write-Host "[OK] Database is ready"
          } else {
            Write-Host "[ERROR] Database check failed"
            docker compose logs db --tail=30
            exit 1
          }

      - name: Smoke Test - MinIO Connectivity
        shell: powershell
        run: |
          Write-Host "Testing MinIO connectivity..."
          try {
            $minio = Invoke-WebRequest -Uri "http://localhost:9000/minio/health/live" -TimeoutSec 5
            if ($minio.StatusCode -eq 200) {
              Write-Host "[OK] MinIO is healthy"
            }
          } catch {
            Write-Host "[ERROR] MinIO health check failed: $_"
            docker compose logs minio --tail=30
            exit 1
          }

      - name: Collect logs
        if: always()
        shell: powershell
        run: |
          Write-Host "Collecting logs..."
          New-Item -ItemType Directory -Force -Path logs | Out-Null
          
          $services = @('app', 'db', 'minio')
          
          $runningServices = docker compose ps --services
          if ($runningServices -contains 'airflow-webserver') {
            $services += @('airflow-webserver', 'airflow-scheduler')
          }
          
          foreach ($service in $services) {
            Write-Host "Collecting logs for $service..."
            docker compose logs --tail=200 $service > "logs/${service}.log" 2>&1
          }
          
          Write-Host "[OK] Logs collected"

      - name: Install MinIO Client
        if: always()
        shell: powershell
        run: |
          if (-not (Test-Path "mc.exe")) {
            Write-Host "Downloading MinIO Client..."
            Invoke-WebRequest `
              -Uri "https://dl.min.io/client/mc/release/windows-amd64/mc.exe" `
              -OutFile "mc.exe"
            Write-Host "[OK] MinIO Client downloaded"
          } else {
            Write-Host "[OK] MinIO Client already exists"
          }

      - name: Upload artifacts to MinIO
        if: always()
        shell: powershell
        continue-on-error: true
        run: |
          Write-Host "Configuring MinIO..."
          
          # Get MinIO container IP or use localhost
          $minioContainer = docker compose ps minio --format json | ConvertFrom-Json
          
          if ($minioContainer) {
            # Use MC_HOST_ environment variable
            $minioHost = "localhost"
            $minioPort = "9000"
            
            $env:MC_HOST_myminio = "http://$($env:MINIO_ACCESS_KEY):$($env:MINIO_SECRET_KEY)@${minioHost}:${minioPort}"
            
            Write-Host "MinIO endpoint: ${minioHost}:${minioPort}"
            
            # Wait for MinIO to be accessible
            $maxWait = 30
            $waited = 0
            $minioReady = $false
            
            while (-not $minioReady -and $waited -lt $maxWait) {
              try {
                $healthCheck = Invoke-WebRequest -Uri "http://${minioHost}:${minioPort}/minio/health/live" -TimeoutSec 2 -ErrorAction SilentlyContinue
                if ($healthCheck.StatusCode -eq 200) {
                  $minioReady = $true
                  Write-Host "[OK] MinIO is accessible"
                }
              } catch {
                Write-Host "Waiting for MinIO to be accessible..."
                Start-Sleep -Seconds 2
                $waited += 2
              }
            }
            
            if (-not $minioReady) {
              Write-Host "[WARNING] MinIO not accessible, skipping artifact upload"
              exit 0
            }
            
            # Create buckets
            Write-Host "Creating buckets..."
            .\mc.exe mb --ignore-existing myminio/cd-logs 2>&1 | Write-Host
            .\mc.exe mb --ignore-existing myminio/cd-artifacts 2>&1 | Write-Host
            
            # Create timestamped path
            $timestamp = Get-Date -Format "yyyy-MM-dd-HHmmss"
            $repo = "${{ github.repository }}" -replace '/', '-'
            $runId = "${{ github.run_id }}"
            $basePath = "${repo}/${{ github.ref_name }}/${runId}-${timestamp}"
            
            Write-Host "Artifact path: $basePath"
            
            # Upload logs
            if (Test-Path "logs") {
              Write-Host "Uploading logs..."
              $uploadResult = .\mc.exe cp --recursive logs/ "myminio/cd-logs/${basePath}/" 2>&1
              Write-Host $uploadResult
              Write-Host "[OK] Logs uploaded"
            }
            
            # Upload any test results if they exist
            if (Test-Path "test-results") {
              Write-Host "Uploading test results..."
              $uploadResult = .\mc.exe cp --recursive test-results/ "myminio/cd-artifacts/${basePath}/test-results/" 2>&1
              Write-Host $uploadResult
              Write-Host "[OK] Test results uploaded"
            }
            
            # Generate output
            $logsUrl = "http://localhost:9000/cd-logs/${basePath}/"
            $consoleUrl = "http://localhost:9001"
            
            Write-Host ""
            Write-Host "========================================"
            Write-Host "Deployment Artifacts:"
            Write-Host "  Logs: $logsUrl"
            Write-Host "  MinIO Console: $consoleUrl"
            Write-Host "  Path: $basePath"
            Write-Host "========================================"
          } else {
            Write-Host "[WARNING] MinIO container not found, skipping upload"
          }

      - name: Upload logs to GitHub Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs-${{ github.run_id }}
          path: logs/
          retention-days: 7
          if-no-files-found: warn

      - name: Display service status
        if: always()
        shell: powershell
        run: |
          Write-Host ""
          Write-Host "========================================"
          Write-Host "Service Status:"
          Write-Host "========================================"
          docker compose ps
          Write-Host ""
          Write-Host "========================================"
          Write-Host "Access URLs:"
          Write-Host "  API: http://localhost:8080"
          Write-Host "  MinIO Console: http://localhost:9001"
          Write-Host "  Airflow: http://localhost:8081"
          Write-Host "========================================"

      - name: Cleanup old artifacts
        if: success()
        shell: powershell
        continue-on-error: true
        run: |
          Write-Host "Cleaning up old artifacts (>7 days)..."
          
          try {
            $env:MC_HOST_myminio = "http://$($env:MINIO_ACCESS_KEY):$($env:MINIO_SECRET_KEY)@localhost:9000"
            
            $cutoffDate = (Get-Date).AddDays(-7)
            
            $buckets = @('cd-logs', 'cd-artifacts')
            foreach ($bucket in $buckets) {
              Write-Host "Checking bucket: $bucket"
              
              try {
                $objects = .\mc.exe ls --recursive "myminio/${bucket}/" --json 2>&1 | 
                  Where-Object { $_ -match '^\{' } | 
                  ConvertFrom-Json
                
                foreach ($obj in $objects) {
                  if ($obj.lastModified) {
                    $objDate = [DateTime]::Parse($obj.lastModified)
                    if ($objDate -lt $cutoffDate) {
                      Write-Host "Removing: $($obj.key)"
                      .\mc.exe rm "myminio/${bucket}/$($obj.key)" 2>&1 | Out-Null
                    }
                  }
                }
              } catch {
                Write-Host "[WARNING] Could not clean bucket $bucket - $_"
              }
            }
            
            Write-Host "[OK] Cleanup complete"
          } catch {
            Write-Host "[WARNING] Cleanup failed: $_"
          }